

export getAlpha, getBeta, getX,ParamLevelSetModelFunc

type infoForJacobian
	Is 						:: Array{Array{Int32,1}}
	Vs 						:: Array
end

function ParamLevelSetModelFunc(Mesh::RegularMesh,m::Vector; computeJacobian = 1, bf::Int64 = 1,
		 sigma::Function = (m)->(m,Diagonal(ones(prod(size(m))))),
		 Xc = getCellCenteredGrid(Mesh),u::Vector = zeros(prod(Mesh.n)))
	n = Mesh.n;
	# n_tup = tuple(n...);
	if length(u) != prod(n)
		error("preallocated u is of wrong size");
	end
	u[:] = 0.0;

	h = Mesh.h;
	nRBFs = div(length(m),5);
	xmin = Mesh.domain[[1;3;5]];
	o = ones(Int64,3);
	infoJ = infoForJacobian(Array{Array{Int32,1}}(nRBFs),Array{Array{Float32,2}}(nRBFs))
	nnzJ = 0;
	J = spzeros(prod(n),5*nRBFs);
	Is = zeros(Int32,0);
	Js = zeros(Int32,0);
	Vs = zeros(Float32,0);
	
	Ibig = zeros(Int32,0);
	
	## in run 1 we calculate u. in run 2 we calculate J after we know the derivative of the heavySide. 
	ii_count = 1;
	iishift3 = 0;
	iishift2 = 0;
	argii = 0.0;
	alpha = 0.0;
	beta = 0.0;
	xx = zeros(3);
	# println("~~~~~~~~~~~~~~~~")
	# tic()
	for k=1:nRBFs
		x = getX(k,m);
		i = round.(Int64,(x - xmin)./h + 0.5);
		@inbounds if (i[1] <=  1) || (i[1] > n[1]) || (i[2] < 1) || (i[2] > n[2])|| (i[3] < 1) || (i[3] > n[3])
			warn("RBFapprox: x went out of bounds.");			
			infoJ.Is[k] = zeros(Int32,0);
			continue;
		end
		## here we take a reasonable box around the bf. 
		## The constant depends on the type of RBF that we take.
		beta = getBeta(k,m);
		boxL = ceil.(Int64,0.9./(h*abs(beta)));
		imax = min.(i + boxL,n);
		imin = max.(i - boxL,o);
		
		
		# (I1,I2,I3) = meshgrid(imin[1]:imax[1],imin[2]:imax[2],imin[3]:imax[3]);
		# I = Base.sub2ind(n_tup,I1[:],I2[:],I3[:]);
		# Xk = Xc[I,:];
		# Xk[:,1] .-= x[1];
		# Xk[:,2] .-= x[2];
		# Xk[:,3] .-= x[3];


		# Xk .*= getBeta(k,m);
		# arg = radius(Xk)[1];
		
		# Fk = psi(arg,bf);
		# alpha = getAlpha(k,m);
		# Fk   .*= alpha;
		# u[I] .+= Fk;
		
		alpha = getAlpha(k,m);
		newBig = ceil(Int64,prod(imax.-imin));
		if newBig > length(Ibig)
			Ibig = zeros(Int32,newBig);
		end
		ii_count = 1;
		@inbounds for l = imin[3]:imax[3]
			@inbounds iishift3 = (l-1)*n[1]*n[2];
			@inbounds for j = imin[2]:imax[2]
				@inbounds iishift2 = iishift3 + (j-1)*n[1];
				@inbounds for i = imin[1]:imax[1]
					ii = iishift2 + i;
					@inbounds xx[1] = beta*(Xc[ii,1] - x[1]);
					@inbounds xx[2] = beta*(Xc[ii,2] - x[2]);
					@inbounds xx[3] = beta*(Xc[ii,3] - x[3]);
					@inbounds argii = radius(xx);
					if (argii <= 0.875)
						@inbounds Ibig[ii_count] = ii;
						argii = alpha*psi(argii,bf);
						@inbounds u[ii] += argii; 
						ii_count += 1;
					end
				end
			end
		end
		@inbounds I = Ibig[1:(ii_count-1)];
		if computeJacobian == 1
			@inbounds infoJ.Is[k] = I;
			nnzJ += 5*length(I);
		end
	end
	# toc()
	
	su,dsu = sigma(u);
	if computeJacobian == 1
	
		# tic()
		# println("Before dsigma J has ",nnzJ," nnz");
		nnzJ = 0;
		dsu = diag(dsu);
		md = maximum(abs.(dsu));
		for k=1:nRBFs
			Ik = infoJ.Is[k];
			Ik = Ik[dsu[Ik].>=1e-3*md];
			if isempty(Ik)
				infoJ.Is[k] = Ik;
				continue;
			end
			x = getX(k,m);
			alpha = getAlpha(k,m);
			beta = getBeta(k,m);
			
			
			betaSQ = beta^2;
			invBeta = (1/beta);
			alphaBetaSq = (alpha*betaSQ);
			Vk = zeros(Float32,length(Ik),5);
			
			for iik = 1:length(Ik)
				@inbounds ii = Ik[iik];
				@inbounds dsuii = dsu[ii];
				@inbounds xx[1] = (Xc[ii,1] - x[1]);
				@inbounds xx[2] = (Xc[ii,2] - x[2]);
				@inbounds xx[3] = (Xc[ii,3] - x[3]);
				nX = dot(xx,xx);
				radii = radiust(nX*betaSQ);
				nX *= invBeta;
				temp  = dsuii*dpsi(radii,bf)*(alphaBetaSq/radii);
				nX *= temp;
				@inbounds Vk[iik,1] = dsuii*psi(radii,bf);
				@inbounds Vk[iik,2] = nX;
				temp*=-1.0;
				@inbounds Vk[iik,3] = temp*xx[1];
				@inbounds Vk[iik,4] = temp*xx[2];
				@inbounds Vk[iik,5] = temp*xx[3];
				
			end
			# print(length(Vk[:]))
			# println("->",sum(Vk[:].!=0.0))
			
			# Xk = Xc[Ik,:];
			# Xk[:,1] .-= x[1];
			# Xk[:,2] .-= x[2];
			# Xk[:,3] .-= x[3];
			
			# radiik,n_betaXsq = radius(beta*Xk);
			# arg = radiik
						
			# Fk = psi(arg,bf);
			# dFk  = alpha*dpsi(arg,bf);
			
			# n_betaXsq = n_betaXsq*(1/(beta^3));
			# temp = (beta^2)*(dFk./radiik);
			# Vk    = dsu[Ik].*[Fk (n_betaXsq.*temp) -temp.*Xk[:,1] -temp.*Xk[:,2] -temp.*Xk[:,3]];
			
			
			
			
			# aVk = abs.(Vk);
			# mv = maximum(aVk);
			# Vk[aVk.<= 1e-2*mv] = 0.0;
			infoJ.Is[k] = Ik;
			infoJ.Vs[k] = Vk;
			nnzJ += 5*length(Ik);
		end
		# toc()
		# tic()
		# println(nnzJ);
		Is = ones(Int32,nnzJ);
		Js = ones(Int32,nnzJ);
		Vs = zeros(Float32,nnzJ);
		
		curr = 1;
		for k=1:nRBFs
			# Jk = sparse([I;I;I;I;I],
				# kron((k-1)*5 + [1;2;3;4;5],ones(Int64,length(I))),
				# Vnz,prod(n),5*length(alpha));
			Ik = infoJ.Is[k];
			if isempty(Ik)
				continue;
			end
			gIdx = curr:(curr+5*length(Ik)-1);
			Is[gIdx] = kron(ones(Int32,5),Ik);
			Js[gIdx] = kron((k-1)*5 + collect(1:5),ones(Int32,length(Ik)));
			Vs[gIdx] = infoJ.Vs[k];
			infoJ.Vs[k] = zeros(Float32,0,0);
			infoJ.Is[k] = zeros(Int32,0);
			curr+=length(gIdx);

		end
		# toc()
		
		# J = sparse(Is,Js,Vs,prod(n),length(m));
	end
	return su,Is,Js,Vs;
	# return su,J;
	
end


function getAlpha(k::Int64,m::Union{Array{Float64,1},Array{Float32,1}})
	return m[5*(k-1) + 1];
end

function getBeta(k::Int64,m::Union{Array{Float64,1},Array{Float32,1}})
	return m[5*(k-1) + 2];
end

function getX(k::Int64,m::Union{Array{Float64,1},Array{Float32,1}})
	return m[5*(k-1)+(3:5)];
end

function setX(k::Int64,m::Union{Array{Float64,1},Array{Float32,1}},x::Array)
	m[5*(k-1)+(3:5)] = x;
end


function psi(r::Union{Array{Float64,1},Array{Float32,1},Float64},bf = 1)
	rpp = max.(1.0-r,0.0);
	if bf==1
		psi = (rpp.^4).*(4.0*r + 1.0);
	elseif bf == 2
		psi = (rpp.^6).*((11.6666666)*r.^2 + 6.0*r + 1.0); ### this is the RBF divided by 3. No idea what went wrong there...
	elseif bf == 3
		psi = (rpp.^8).*(32.0*(r.^3) + 25.*(r.^2) + 8.0.*r + 1.0);
	end
	return psi;
end


# function psi(r::Float64,bf = 1)
	# rpp = max(1.0-r,0.0);
	# if bf==1
		# psi = (rpp^4)*(4.0*r + 1.0);
	# elseif bf == 2
		# psi = (rpp^6)*((11.6666666)*r^2 + 6.0*r + 1.0); ### this is the RBF divided by 3. No idea what went wrong there...
	# elseif bf == 3
		# psi = (rpp^8)*(32.0*(r.^3) + 25*(r^2) + 8.0*r + 1.0);
	# end
	# return psi;
# end

function dpsi(r::Union{Array{Float64,1},Array{Float32,1},Float64},bf = 1)
	rpp = max.(1.0-r,0.0);
	if bf==1
		dpsi = -4.0*(rpp.^3).*(4.0*r + 1.0) + (rpp.^4).*4.0;
	elseif bf == 2
		dpsi = -6.0*(rpp.^5).*((11.6666666)*r.^2 + 6.0*r + 1.0) + (rpp.^6).*((2.0*11.6666666)*r + 6.0); ### this is the RBF divided by 3. No idea what went wrong there...
	elseif bf == 3
		dpsi = -8.0*(rpp.^7).*(32.0*(r.^3) + 25.*(r.^2) + 8.0.*r + 1.0) + (rpp.^8).*(96.0*(r.^2) + 50.*r + 8.0);
	end
	return dpsi;
end

function radius(x::Union{Array{Float64,2},Array{Float32,2}},eps::Float64 = 1e-3)
t = vec(sum(x.^2,2));
return (sqrt.(t + eps),t);
end

function radius(x::Union{Vector{Float64},Vector{Float32}},eps::Float64 = 1e-3)
t = dot(x,x);
return sqrt(t + eps);
end

function radiust(t::Float64,eps::Float64 = 1e-3)
return sqrt(t + eps);
end

export splitTheta,wrapTheta
function splitTheta(theta::Array)
	n = div(length(theta),5);
	if 5*n != length(theta)
		error("Inappropriate length of theta");
	end
	alpha = theta[1:5:end];
	beta = theta[2:5:end];
	Xs = [theta[3:5:end] theta[4:5:end] theta[5:5:end]];
	return (alpha,beta,Xs)
end

function wrapTheta( alpha:: Array{Float64},	beta:: Array{Float64}, Xs:: Array{Float64})
	theta = zeros(5*length(alpha));
	theta[1:5:end] = alpha;
	theta[2:5:end] = beta;
	theta[3:5:end] = Xs[:,1];
	theta[4:5:end] = Xs[:,2];
	theta[5:5:end] = Xs[:,3];
	return theta
end



